/*
 * CodeScan for IntelliJ IDEA
 * Copyright (C) 2015-2021 SonarSource
 * sonarlint@sonarsource.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
 */
package org.sonarlint.intellij.ui.tree

import com.intellij.ide.DefaultTreeExpander
import com.intellij.openapi.actionSystem.ActionManager
import com.intellij.openapi.actionSystem.ActionPlaces
import com.intellij.openapi.actionSystem.CommonDataKeys
import com.intellij.openapi.actionSystem.DataProvider
import com.intellij.openapi.actionSystem.DefaultActionGroup
import com.intellij.openapi.actionSystem.IdeActions
import com.intellij.openapi.actionSystem.PlatformDataKeys
import com.intellij.openapi.editor.RangeMarker
import com.intellij.openapi.fileEditor.OpenFileDescriptor
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.VirtualFile
import com.intellij.psi.PsiDocumentManager
import com.intellij.psi.PsiManager
import com.intellij.ui.PopupHandler
import com.intellij.ui.treeStructure.Tree
import com.intellij.util.EditSourceOnDoubleClickHandler
import com.intellij.util.EditSourceOnEnterKeyHandler
import org.sonarlint.intellij.actions.OpenIssueInBrowserAction
import org.sonarlint.intellij.common.util.SonarLintUtils.getService
import org.sonarlint.intellij.editor.EditorDecorator
import org.sonarlint.intellij.issue.vulnerabilities.LocalTaintVulnerability
import org.sonarlint.intellij.telemetry.SonarLintTelemetry
import org.sonarlint.intellij.ui.nodes.FileNode
import org.sonarlint.intellij.ui.nodes.LocalTaintVulnerabilityNode
import org.sonarlint.intellij.ui.nodes.taint.vulnerabilities.FlowNode
import org.sonarlint.intellij.ui.nodes.taint.vulnerabilities.LocationFileGroupNode
import org.sonarlint.intellij.ui.nodes.taint.vulnerabilities.LocationNode
import javax.swing.event.TreeExpansionEvent
import javax.swing.event.TreeExpansionListener
import javax.swing.tree.DefaultMutableTreeNode
import javax.swing.tree.TreeModel
import javax.swing.tree.TreePath

class TaintVulnerabilityTree(private val project: Project, model: TreeModel) : Tree(model), DataProvider {

  private var selectedTaintVulnerabilityKey : String? = null

  init {
    setShowsRootHandles(false)
    setCellRenderer(TreeCellRenderer())
    expandRow(0)
    selectionModel.addTreeSelectionListener {
      val issueKey = getIssueFromSelectedNode()?.key()
      if (issueKey != null && issueKey != selectedTaintVulnerabilityKey) {
        getService(SonarLintTelemetry::class.java).taintVulnerabilitiesInvestigatedLocally()
      }
      selectedTaintVulnerabilityKey = issueKey
      getSelectedNode()?.let { highlightInEditor(it) }
    }
    addTreeExpansionListener(object : TreeExpansionListener {
      override fun treeExpanded(event: TreeExpansionEvent) {
        expandUniqueFlowNode(event.path.lastPathComponent as DefaultMutableTreeNode)
      }

      override fun treeCollapsed(event: TreeExpansionEvent?) {
        // not interested
      }
    })
    val group = DefaultActionGroup()
    group.add(ActionManager.getInstance().getAction(IdeActions.ACTION_EDIT_SOURCE))
    group.add(OpenIssueInBrowserAction())
    group.addSeparator()
    group.add(ActionManager.getInstance().getAction(IdeActions.ACTION_EXPAND_ALL))
    PopupHandler.installPopupHandler(this, group, ActionPlaces.TODO_VIEW_POPUP, ActionManager.getInstance())
    EditSourceOnDoubleClickHandler.install(this) { showInEditor(getSelectedNode()) }
    EditSourceOnEnterKeyHandler.install(this) { showInEditor(getSelectedNode()) }
  }

  private fun expandUniqueFlowNode(node: DefaultMutableTreeNode) {
    if (node is LocalTaintVulnerabilityNode && node.issue.flows.size == 1) {
      expandPath(TreePath((node.firstChild as DefaultMutableTreeNode).path))
    }
  }

  private fun showInEditor(node: DefaultMutableTreeNode?) {
    node?.let {
      highlightInEditor(it)
      navigateToEditor(it)
    }
  }

  private fun navigateToEditor(node: DefaultMutableTreeNode) {
    var rangeMarker: RangeMarker? = null
    if (node is FlowNode) {
      rangeMarker = node.flow.locations[0].range
    } else if (node is LocationNode) {
      rangeMarker = node.location.range
    }
    if (rangeMarker == null || !rangeMarker.isValid) {
      return
    }

    val psiFile = PsiDocumentManager.getInstance(project).getPsiFile(rangeMarker.document)
    if (psiFile != null && psiFile.isValid) {
      OpenFileDescriptor(project, psiFile.virtualFile, rangeMarker.startOffset).navigate(false)
    }
  }

  private fun highlightInEditor(node: DefaultMutableTreeNode) {
    val highlighter = getService(project, EditorDecorator::class.java)
    when (node) {
      is FlowNode -> highlighter.highlightFlow(node.flow)
      is LocationNode -> highlighter.highlightSecondaryLocation(node.location, node.associatedFlow)
      is LocalTaintVulnerabilityNode -> highlighter.highlight(node.issue)
      is LocationFileGroupNode -> highlighter.highlight(node.issue)
    }
  }

  private fun navigate(): OpenFileDescriptor? {
    val issue = getSelectedIssue() ?: return null
    if (!issue.isValid()) {
      return null
    }
    val file = issue.file() ?: return null
    val offset = issue.rangeMarker()?.startOffset ?: 0
    return OpenFileDescriptor(project, file, offset)
  }

  fun getSelectedIssue(): LocalTaintVulnerability? {
    val node = getSelectedNode()
    return if (node !is LocalTaintVulnerabilityNode) {
      null
    } else node.issue
  }

  private fun getSelectedFile(): VirtualFile? {
    val node = getSelectedNode() as? FileNode ?: return null
    return node.file()
  }

  fun getSelectedNode(): DefaultMutableTreeNode? {
    val path = selectionPath ?: return null
    return path.lastPathComponent as DefaultMutableTreeNode
  }

  override fun getData(dataId: String): Any? {
    return when {
      CommonDataKeys.NAVIGATABLE.`is`(dataId) -> navigate()
      PlatformDataKeys.TREE_EXPANDER.`is`(dataId) -> DefaultTreeExpander(this)
      PlatformDataKeys.VIRTUAL_FILE.`is`(dataId) -> getSelectedFile()
      PlatformDataKeys.PSI_FILE.`is`(dataId) -> {
        val file = getSelectedFile()
        if (file != null && file.isValid) {
          PsiManager.getInstance(project).findFile(file)
        } else null
      }
      PlatformDataKeys.VIRTUAL_FILE_ARRAY.`is`(dataId) -> {
        val f = getSelectedFile()
        // return empty so that it doesn't find it in parent components
        if (f != null && f.isValid) arrayOf(f) else arrayOfNulls<VirtualFile>(0)
      }
      OpenIssueInBrowserAction.TAINT_VULNERABILITY_DATA_KEY.`is`(dataId) -> getSelectedIssue()
      else -> null
    }
  }

  fun getIssueFromSelectedNode(): LocalTaintVulnerability? {
    val node = getSelectedNode() ?: return null
    return when (node) {
      is LocalTaintVulnerabilityNode -> node.issue
      is FlowNode -> node.issue
      is LocationFileGroupNode -> node.issue
      is LocationNode -> node.issue
      else -> null
    }
  }

}

