/*
 * CodeScan for IntelliJ IDEA
 * Copyright (C) 2015-2021 SonarSource
 * sonarlint@sonarsource.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02
 */
package org.sonarlint.intellij.ui.tree

import com.google.common.collect.ComparisonChain
import com.google.common.collect.ImmutableList
import com.google.common.collect.Ordering
import com.intellij.openapi.vfs.VirtualFile
import org.sonarlint.intellij.issue.Flow
import org.sonarlint.intellij.issue.vulnerabilities.LocalTaintVulnerability
import org.sonarlint.intellij.ui.nodes.AbstractNode
import org.sonarlint.intellij.ui.nodes.FileNode
import org.sonarlint.intellij.ui.nodes.IssueNode
import org.sonarlint.intellij.ui.nodes.LocalTaintVulnerabilityNode
import org.sonarlint.intellij.ui.nodes.SummaryNode
import org.sonarlint.intellij.ui.nodes.taint.vulnerabilities.FlowNode
import org.sonarlint.intellij.ui.nodes.taint.vulnerabilities.LocationFileGroupNode
import org.sonarlint.intellij.ui.nodes.taint.vulnerabilities.LocationNode
import javax.annotation.Nonnull
import javax.swing.tree.DefaultTreeModel

class TaintVulnerabilityTreeModelBuilder {

  private val issueComparator: Comparator<LocalTaintVulnerability> = LocalTaintVulnerabilityComparator()

  private val index = IssueTreeIndex()
  private val summary = SummaryNode()
  val model = DefaultTreeModel(summary)

  fun numberIssues() = summary.issueCount

  fun updateModel(map: Map<VirtualFile, Collection<LocalTaintVulnerability>>) {
    index.allFiles
      .filter { !map.containsKey(it) }
      .forEach { removeFile(it) }
    for ((key, value) in map) {
      setFileIssues(key, value)
    }
  }

  private fun setFileIssues(file: VirtualFile, issues: Iterable<LocalTaintVulnerability>) {
    if (!accept(file)) {
      removeFile(file)
      return
    }
    if (issues.toList().isEmpty()) {
      removeFile(file)
      return
    }
    var newFile = false
    var fNode = index.getFileNode(file)
    if (fNode == null) {
      newFile = true
      fNode = FileNode(file)
      index.setFileNode(fNode)
    }
    addIssuesNode(fNode, issues)
    if (newFile) {
      val parent = summary
      val idx = parent.insertFileNode(fNode, FileNodeComparator())
      val newIdx = intArrayOf(idx)
      model.nodesWereInserted(parent, newIdx)
    }
    model.reload()
  }

  private fun removeFile(file: VirtualFile) {
    val node = index.getFileNode(file)
    if (node != null) {
      index.remove(node.file())
      model.removeNodeFromParent(node)
    }
  }

  private fun addIssuesNode(node: FileNode, issues: Iterable<LocalTaintVulnerability>) {
    node.removeAllChildren()

    issues
      .sortedWith(issueComparator)
      .forEach { issue ->
        val issueNode = LocalTaintVulnerabilityNode(issue)
        issue.flows.forEachIndexed { index, flow -> addFlowNode(issueNode, flow, index + 1) }
        node.add(issueNode)
      }
  }

  private fun addFlowNode(issueNode: LocalTaintVulnerabilityNode, flow: Flow, flowIndex: Int) {
    val flowNode = FlowNode(flow, "Flow $flowIndex", issueNode.issue)
    issueNode.add(flowNode)


    var locationsByFileSequence: List<LocationFileGroupNode> = mutableListOf()
    var groupIndex = 0
    locationsByFileSequence = flow.locations.foldIndexed(locationsByFileSequence, { index, acc, location ->
      var result = acc
      var last = acc.lastOrNull()
      if (last == null || last.file() != location.file) {
        last = LocationFileGroupNode(groupIndex++, location, flowNode.issue)
        result = acc + last
      }
      last.add(LocationNode(index + 1, location, flowNode.flow, flowNode.issue))
      result
    })
    locationsByFileSequence.forEach { flowNode.add(it) }
  }

  private fun accept(file: VirtualFile): Boolean {
    return file.isValid
  }

  private class FileNodeComparator : Comparator<FileNode> {
    override fun compare(o1: FileNode, o2: FileNode): Int {
      val c = o1.file().name.compareTo(o2.file().name)
      return if (c != 0) {
        c
      } else o1.file().path.compareTo(o2.file().path)
    }
  }

  internal class LocalTaintVulnerabilityComparator : Comparator<LocalTaintVulnerability> {
    private val severityOrder: List<String> = ImmutableList.of("BLOCKER", "CRITICAL", "MAJOR", "MINOR", "INFO")

    override fun compare(@Nonnull o1: LocalTaintVulnerability, @Nonnull o2: LocalTaintVulnerability): Int {

      val dateCompare = o1.creationDate().compareTo(o2.creationDate())
      if (dateCompare != 0) {
        return dateCompare
      }
      val severityCompare = Ordering.explicit<String>(severityOrder).compare(o1.severity(), o2.severity())
      if (severityCompare != 0) {
        return severityCompare
      }

      val r1 = o1.rangeMarker()
      val r2 = o2.rangeMarker()

      val rangeStart1 = r1?.startOffset ?: -1
      val rangeStart2 = r2?.startOffset ?: -1
      return ComparisonChain.start()
        .compare(rangeStart1, rangeStart2)
        .compare(o1.ruleKey(), o2.ruleKey())
        .result()
    }
  }

  fun getNextIssue(startNode: AbstractNode): IssueNode? {
    if (startNode !is IssueNode) {
      return firstIssueDown(startNode)
    }
    val next = getNextNode(startNode)
      ?: // no next node in the entire tree
      return null
    return if (next is IssueNode) {
      next
    } else firstIssueDown(next)
  }

  fun getPreviousIssue(startNode: AbstractNode): IssueNode? {
    val next = getPreviousNode(startNode)
      ?: // no next node in the entire tree
      return null
    return if (next is IssueNode) {
      next
    } else lastIssueDown(next)
  }

  /**
   * Finds the first issue node which is child of a given node.
   */
  private fun firstIssueDown(node: AbstractNode): IssueNode? {
    if (node is IssueNode) {
      return node
    }
    if (node.childCount > 0) {
      val firstChild = node.firstChild
      return firstIssueDown(firstChild as AbstractNode)
    }
    return null
  }

  /**
   * Finds the first issue node which is child of a given node.
   */
  private fun lastIssueDown(node: AbstractNode): IssueNode? {
    if (node is IssueNode) {
      return node
    }
    val lastChild = node.lastChild ?: return null
    return lastIssueDown(lastChild as AbstractNode)
  }

  private fun getPreviousNode(startNode: AbstractNode): AbstractNode? {
    val parent = startNode.parent as AbstractNode?
      ?: return null
    val previous = parent.getChildBefore(startNode) ?: return getPreviousNode(parent)
    return previous as AbstractNode
  }

  /**
   * Next node, either the sibling if it exists, or the sibling of the parent
   */
  private fun getNextNode(startNode: AbstractNode): AbstractNode? {
    val parent = startNode.parent as AbstractNode?
      ?: return null
    val after = parent.getChildAfter(startNode) ?: return getNextNode(parent)
    return after as AbstractNode
  }

  companion object {
  }
}
